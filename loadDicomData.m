function [ data, origin, basis, voxelSpacing, sliceThickness] = loadDicomData( filename, kbqcc )
% WARING: This documentation is NOT up-to-date, especially concering the
% "kbqcc" parameter. Please don't use it or set it to false, unless you
% understand the code!
%
% loadDicomData     reads the dicom infos and pixel data, and preprocess
%                   the pixel data according to the
%                   RescaleSlope-Intercept/LUT mechanisme.
%
%   loadDicomData extract the voxel values and a set of informations about
%   the geometric details from the dicom file filename. The voxel values
%   are rescaled to match the units specified in the Units dicom tag of
%   filename.
%
%   Input Arguments:
%
%   filename        is a character string of the path of a multiframe dicom
%                   file.
%
%   Output Arguments:
%
%   data            is a 3D array of double, in units of the Units dicom
%                   tag of filename,
%   origin          is the origin of the first voxel of data, in cartesian
%                   coordinate, in the Patient's Coordinate System (PCS),
%   basis           is the basis matrix of the three pricipal directions of
%                   the data array. basis(:,1) is the vector pointing in
%                   the direction of growing of the first index of data,
%                   basis(:,2), for the second index, etc. These vectors
%                   are in cartesian coordinates in the PCS,
%   voxelSpacing    is an array of the distance between adjacent voxels,
%   sliceThickness  is the width of a slice, for the imagery machinery. 
%                   This width represent the lowpass filter due to the
%                   finite z resolution of the detector.

    if ~exist('kbqcc')
        kbqcc = false;
    end
    
    dcmInfos = dicominfo(filename);
    if ~any(strcmp('NumberOfFrames', fieldnames(dcmInfos)))
        error(['loadDicomData: ', filename, ...
               ': Only multiframe dicom are currently supported']);
    end
    voxelSpacing = getStructField(dcmInfos, {'SharedFunctionalGroupsSequence', ...
                                             'Item_1', ...
                                             'PixelMeasuresSequence', ...
                                             'Item_1', ...
                                             'PixelSpacing'});
    
    basis = reshape(getStructField(dcmInfos, {'PerFrameFunctionalGroupsSequence', ...
                                              'Item_1', ...
                                              'PlaneOrientationSequence', ...
                                              'Item_1', ...
                                              'ImageOrientationPatient'}), 3, 2);
    basis = [basis, cross(basis(:,1), basis(:,2))];
    
    origin  = getStructField(dcmInfos, {'PerFrameFunctionalGroupsSequence', ...
                                        'Item_1', ...
                                        'PlanePositionSequence', ...
                                        'Item_1', ...
                                        'ImagePositionPatient'});
    origin2 = getStructField(dcmInfos, {'PerFrameFunctionalGroupsSequence', ...
                                        'Item_2', ...
                                        'PlanePositionSequence', ...
                                        'Item_1', ...
                                        'ImagePositionPatient'});

    im2imVector = origin2-origin;
    zSpacing = im2imVector.'*basis(:,3);
    voxelSpacing = [ voxelSpacing; zSpacing ];
    sliceThickness = getStructField(dcmInfos, {'SharedFunctionalGroupsSequence', ...
                                               'Item_1', ...
                                               'PixelMeasuresSequence', ...
                                               'Item_1', ...
                                               'SliceThickness'});
    
    RescaleSlope = getStructField(dcmInfos, {'PerFrameFunctionalGroupsSequence', ...
                                             'Item_1', ...
                                             'PixelValueTransformationSequence', ...
                                             'Item_1', ...
                                             'RescaleSlope'});
    RescaleIntercept = getStructField(dcmInfos, {'PerFrameFunctionalGroupsSequence', ...
                                                 'Item_1', ...
                                                 'PixelValueTransformationSequence', ...
                                                 'Item_1', ...
                                                 'RescaleIntercept'});
    [data, ~] = dicomread(dcmInfos);
    data = squeeze( RescaleSlope*double(data) + RescaleIntercept );
    
    if kbqcc
        data = convertToKBQCC(data, dcmInfos.Units, prod(voxelSpacing));
    end
    
    %disp(['Units: ' convertUnits(dcmInfos)]);
end

function [ kbqcc ] = convertToKBQCC( data, units, voxelVolume )
    % there is an unknown proportionality factor between the count number
    % and the becquerel. Hence, it is not possible to infer the activity
    % from the number of counts, or the number of counts per second.
    convTable = { %{'CNTS',  'Counts',                             @(x)(x./(1000.*integrationTime*voxelVolume))}, ...
                  %{'CPS',   'Counts per second',                  @(x) (x./voxelVolume*1000.)}, ...
                  {'BQML',  'Becquerels per milliliter',          @(x) (x./1000.)}, ...
                  {'KBQCC', 'KiloBecquerels per centimeter cube', @(x) (x)} ...
                };
    convertionOp = dictFindPairByKey(convTable, units);
    if ~isempty(convertionOp)
        kbqcc = convertionOp{3}(data);
    else
        error('LoadDicomData', 'Unknown units or no valid unit convertion');
    end
end

function [ humanReadableUnits ] = convertUnits(infos)
    convTable = { {'CNTS',      'Counts'}, ...
                  {'NONE',      'Unitless'}, ...
                  {'CM2',       'Centimeter squared'}, ...
                  {'CM2ML',     'Centimeter squared per milliliter'}, ...
                  {'PCNT',      'Percent'}, ...
                  {'CPS',       'Counts per second'}, ...
                  {'BQML',      'Becquerels per milliliter'}, ...
                  {'MGMINML',   'Milligram per minute per milliliter'}, ...
                  {'UMOLMINML', 'Micromole per minute per milliliter'}, ...
                  {'MLMING',    'Milliliter per minute per gram'}, ...
                  {'MLG',       'Milliliter per gram'}, ...
                  {'1CM',       'Per centimeter'}, ...
                  {'UMOLML',    'Micromole per milliliter'}, ...
                  {'PROPCNTS',  'Proportional to counts'}, ...
                  {'PROPCPS',   'Proportional to counts per second'}, ...
                  {'MLMINML',   'Milliliter per minute per milliliter'}, ...
                  {'MLML',      'Milliliter per milliliter'}, ...
                  {'GML',       'Gram per milliliter'}, ...
                  {'STDDEV',    'Standard deviation'}, ...
                  {'KBQCC',     'KiloBecquerels per centimeter cube'} ...
                };
    
    humanReadableUnits = dictFindValueByKey(convTable, infos.Units);
    if isempty(humanReadableUnits)
        humanReadableUnits = ['Unknown: ' infos.Units];
    else
        humanReadableUnits = humanReadableUnits{1};
    end
end

function [ pair ] = dictFindPairByKey( dict, key )
    pair = {};
    for i = 1:length(dict)
       if strcmp(dict{i}{1}, key)
           pair = dict{i};
           break;
       end
    end
end

function [ value ] = dictFindValueByKey( dict, key )
    value = {};
    for i = 1:length(dict)
       if strcmp(dict{i}{1}, key)
           value = dict{i}(2:end);
           break;
       end
    end
end